## 原子性对比

- synchronize：不可中断锁，适合竞争不激烈，可读性好
- Lock : 可中断锁，多样化同步，竞争激烈时能维持常态
- Atomic：竞争激烈时能维持常态，比Lock性能好；但是只能同步一个值。


## 可见性

- 导致共享变量在线程间不可见的原因

1. 线程交叉执行
2. 重排序结合线程交叉执行
3. 共享变量更新后的值没有在工作内存与主内存及时更新

## 可见性 --- synchronize

- Java内存模型关于synchronize的两条规定

1. 线程解锁前，必须把共享变量的最新值刷新到主内存中
2. 线程加锁前，将清空工作内存中的共享变量的值，从而使用共享变量时需要从主内存重新读取最新的值（注意：加锁和解锁是同一把锁）

### 可见性 --- volatile 

- 通过加入内存屏障和禁止重排序优化来实现

1. 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量刷新到主内存中
2. 对volatile变量读操作时，会在读操作之前加入一条load屏障指令，从主内存中读取共享变量的值

## 发布对象

- 发布对象：
> 1. 使一个对象能够被当前范围之外的代码所使用

- 对象逸出：
> 一种错误的发布。当一个对象还没有构造完成的时候，就使它被其他线程所见

### 安全发布对象

1. 在静态初始化函数中创建一个对象引用
2. 将对象的引用保存到volatile类型域或者AtomicReference对象中
3. 将对象的引用保存到某个正确构造的final类型域中
3. 将对象的引用保存到一个由锁保护的域中

## 不可变对象

- 不可变对象满足的条件：

1. 对象创建以后其状态就不能修改
2. 对象所有域都是final类型
3. 对象是正确创建的（在对象创建期间，this引用没有逸出）

> 可以把类声明为final，表示类不能被继承，所有的成员都是private final ,不提供setter方法；get方法不返回对象本身，而是返回对象的拷贝，可以参考String类

> Collections.unmodifiableXXX 也是不可变的.Guava:ImmutableXXX 

## 线程封闭

- Ad-hoc线程封闭：程序控制实现，最糟糕的，忽略
- 堆栈封闭：使用局部变量，无并发问题
- ThreadLocal线程封闭：特别好的封闭方法